# Комплексные числа

Класс неизменяемого комплексного числа, предоставляющий следующие операции:

- Конструирование без аргументов
- Конструирование от вещественной части
- Конструирование от вещественной и мнимой частей
- Вещественная часть: `double real()`
- Мнимая часть: `double imag()`
- Модуль: `double abs()`
- Перевод в строку: `std::string str()`
- Сложение: `+`, `+=`
- Вычитание: `-`, `-=`
- Умножение: `*`, `*=`
- Деление: `/`, `/=`
- Унарный минус: `-`
- Комплексное сопряжённое: `~`
- Сравнение на равенство: `==`, `!=`
- Вывод в поток: `<<`

# Арифметические выражения

Виды выражений:

- `Const` (в конструкторе передаётся значение)
- `Variable` (в конструкторе передаётся имя переменной)
- `Negate` (унарный минус)
- `Add` (сложение)
- `Subtract` (вычитание)
- `Multiply` (умножение)
- `Divide` (деление)

Пример конструирования выражения `2 * x + 1`:

```cpp
const Add expr(Multiply(Const(2), Variable("x")), Const(1));
```

Над выражениями реализованы соответствующие арифметические операторы.
Таким образом, предыдущий пример можно было бы записать так:

```cpp
const Add expr = Const(2) * Variable("x") + Const(1);
```

Аргументом методу `eval` передаётся отображение из имени переменной в её значение.
Он возвращает результат выражения, используя переданные значения вместо переменных.

```cpp
const Complex result = expr.eval({
    {"x", Complex(100)}
    {"y", Complex(42)}
}); // 201
```

Вспомогательный метод `clone` возвращает указатель на такое же выражение, как то, на котором он вызван,
однако владение над указателем принадлежит вызвавшему метод.

